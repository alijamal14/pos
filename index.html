<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>P2P Items — No Server</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #121937;
      --muted: #8aa0ff;
      --text: #f3f6ff;
      --accent: #5ee6a8;
      --danger: #ff6b6b;
      --card: #0f1530;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(160deg, #0b1020, #0b1530 40%, #0a1130 70%);
      color: var(--text);
      display: grid;
      place-items: start center;
      padding: 24px;
    }
    .app { width: min(1000px, 100%); display: grid; gap: 16px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .card { background: var(--panel); border-radius: 16px; padding: 16px; box-shadow: 0 8px 24px rgba(0,0,0,.25); }
    h1 { margin: 0 0 8px; font-weight: 800; letter-spacing: .2px; }
    h2 { margin: 0 0 12px; font-size: 16px; color: #cfd7ff; text-transform: uppercase; letter-spacing: .1em; }
    .muted { color: #c5ceff99; font-size: 13px; }
    .list { display: grid; gap: 8px; }
    .item { background: var(--card); padding: 12px; border-radius: 12px; display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; }
    .item small { color: #9db0ff; }
    .btn {
      border: 0; border-radius: 12px; padding: 10px 14px; background: #2a3570; color: var(--text); cursor: pointer; font-weight: 600;
    }
    .btn:hover { filter: brightness(1.1); }
    .btn.accent { background: #1b7a61; }
    .btn.danger { background: #7a1b1b; }
    .input { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid #2c3978; background: #0f1530; color: var(--text); }
    textarea.input { min-height: 110px; resize: vertical; }
    code.badge { background: #0f1530; border: 1px solid #2c3978; padding: 6px 10px; border-radius: 999px; font-size: 12px; }
    .flex { display: flex; gap: 8px; }
    .right { text-align: right; }
    .grid2 { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; }
    .pill { padding: 4px 10px; border-radius: 999px; background: #1a2249; font-size: 12px; color: #a8b6ff; }
    .footer { display: flex; justify-content: space-between; align-items: center; }
    .nowrap { white-space: nowrap; }
    .qr-container { display: grid; gap: 8px; align-items: start; }
    .qr-code { border: 1px solid #2c3978; border-radius: 8px; padding: 8px; background: #0f1530; }
    .copy-btn { margin-left: 8px; padding: 4px 8px; font-size: 12px; }
    .status-indicator { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-right: 8px; }
    .status-connected { background: #5ee6a8; }
    .status-disconnected { background: #ff6b6b; }
    .status-pending { background: #ffd93d; }
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <h1>P2P Items (No Server)</h1>
      <div class="footer">
        <div class="muted">Local-first list that syncs peer‑to‑peer via WebRTC <span title="Manual copy/paste signaling. No servers used.">🛰️</span></div>
        <div>
          <span class="pill">Peer ID: <span id="peerId" class="mono"></span></span>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <h2>Items</h2>
        <div class="flex">
          <input id="newText" class="input" placeholder="Add a new item…" />
          <button id="addBtn" class="btn accent">Add</button>
        </div>
        <div class="list" id="list"></div>
      </div>

      <div class="card">
        <h2>Peer‑to‑Peer Linking</h2>
        <p class="muted">Connect devices easily with QR codes or manual copy/paste. No servers required!</p>
        <div class="grid2">
          <button id="createOfferBtn" class="btn">📱 Create Offer</button>
          <span id="connState" class="pill">
            <span class="status-indicator status-disconnected"></span>disconnected
          </span>
        </div>

        <!-- QR Code Section -->
        <div id="qrSection" style="display: none;">
          <label class="muted">📱 Scan this QR code with another device:</label>
          <div class="qr-container">
            <div id="offerQR" class="qr-code"></div>
            <button id="copyOfferBtn" class="btn copy-btn">📋 Copy Text</button>
          </div>
        </div>

        <!-- Manual Section -->
        <details id="manualSection">
          <summary class="muted" style="cursor: pointer; user-select: none;">🔧 Manual Mode (Advanced)</summary>
          <div style="margin-top: 12px;">
            <label class="muted">Your Offer (copy & share)</label>
            <div class="grid2">
              <textarea id="localOffer" class="input" placeholder="Click 'Create Offer'"></textarea>
              <button id="copyOfferTextBtn" class="btn copy-btn">📋 Copy</button>
            </div>
          </div>
        </details>

        <hr style="border-color:#2c3978; opacity:.4;">

        <p class="muted">📲 If you received an <b>Offer</b> from a peer:</p>
        <div class="grid2">
          <input id="remoteOffer" class="input" placeholder="Paste peer's Offer here or scan QR" />
          <div class="flex">
            <button id="scanOfferBtn" class="btn">📷 Scan QR</button>
            <button id="createAnswerBtn" class="btn">📱 Create Answer</button>
          </div>
        </div>

        <!-- Answer Section -->
        <div id="answerSection" style="display: none;">
          <label class="muted">📤 Send this answer back to the peer:</label>
          <div class="qr-container">
            <div id="answerQR" class="qr-code"></div>
            <button id="copyAnswerBtn" class="btn copy-btn">📋 Copy Text</button>
          </div>
        </div>

        <!-- Manual Answer -->
        <details id="manualAnswerSection">
          <summary class="muted" style="cursor: pointer; user-select: none;">🔧 Manual Answer</summary>
          <div style="margin-top: 12px;">
            <label class="muted">Your Answer (copy & share)</label>
            <div class="grid2">
              <textarea id="localAnswer" class="input" placeholder="Paste back to the peer who sent you the Offer"></textarea>
              <button id="copyAnswerTextBtn" class="btn copy-btn">📋 Copy</button>
            </div>
          </div>
        </details>

        <div class="flex">
          <input id="remoteAnswer" class="input" placeholder="Paste peer's Answer here" />
          <button id="applyAnswerBtn" class="btn">✅ Apply Answer</button>
          <button id="disconnectBtn" class="btn danger">❌ Disconnect</button>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Debug</h2>
      <div class="flex">
        <button id="exportBtn" class="btn">Export JSON</button>
        <button id="importBtn" class="btn">Import JSON</button>
        <input type="file" id="filePick" hidden accept="application/json" />
        <span class="muted">Local items are stored in IndexedDB. Sync uses id+timestamp (LWW) merge with tombstones.</span>
      </div>
      <div class="muted">Connections: <code class="badge" id="stats">0 peers</code></div>
    </div>
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
  <!-- Backup QR scanner library -->
  <script src="https://unpkg.com/html5-qrcode@2.3.8/minified/html5-qrcode.min.js"></script>
  <script>
(async () => {
  // Wait for QR code library to load
  let qrCodeReady = false;
  let jsQRReady = false;
  
  const checkLibraries = () => {
    if (typeof QRCode !== 'undefined' && !qrCodeReady) {
      qrCodeReady = true;
      console.log('✅ QRCode library loaded successfully');
    }
    if (typeof jsQR !== 'undefined' && !jsQRReady) {
      jsQRReady = true;
      console.log('✅ jsQR library loaded successfully');
      
      // Update scanner status if modal is open
      const statusEl = document.getElementById('scannerStatus');
      if (statusEl) {
        statusEl.textContent = '✅ Scanner ready';
        statusEl.style.color = '#5ee6a8';
      }
    }
    
    if (!qrCodeReady || !jsQRReady) {
      setTimeout(checkLibraries, 100);
    }
  };
  checkLibraries();

  // -------- Utilities --------
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));
  const now = () => new Date().toISOString();
  const uuid = () => (crypto.randomUUID ? crypto.randomUUID() : ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,c=>(c^crypto.getRandomValues(new Uint8Array(1))[0]&15>>c/4).toString(16)));
  const clamp = (n, a, b) => Math.max(a, Math.min(n, b));
  const debounce = (fn, ms=120) => { let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); }; };

  // -------- Identity --------
  const peerId = localStorage.getItem('peerId') || (() => { const id = uuid().slice(0,8); localStorage.setItem('peerId', id); return id; })();
  document.getElementById('peerId').textContent = peerId;

  // -------- IndexedDB (simple wrapper) --------
  const DB_NAME = 'p2p-items-db';
  const DB_STORE = 'items';
  let db;
  function openDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = (e) => {
        const d = e.target.result;
        const store = d.createObjectStore(DB_STORE, { keyPath: 'id' });
        store.createIndex('updatedAt', 'updatedAt');
      };
      req.onsuccess = () => { db = req.result; resolve(); };
      req.onerror = () => reject(req.error);
    });
  }
  async function getAll() {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, 'readonly');
      const store = tx.objectStore(DB_STORE);
      const res = [];
      store.openCursor().onsuccess = (e) => {
        const c = e.target.result; if (c) { res.push(c.value); c.continue(); } else resolve(res);
      };
      tx.onerror = () => reject(tx.error);
    });
  }
  async function put(item) {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, 'readwrite');
      tx.objectStore(DB_STORE).put(item);
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }

  await openDB();

  // -------- Local state & rendering --------
  /** item: { id, text, updatedAt, deleted, author } */
  let items = {};
  function toArray(map) { return Object.values(map).sort((a,b) => (b.updatedAt||'').localeCompare(a.updatedAt||'')); }

  async function loadFromDB() {
    const rows = await getAll();
    items = {};
    for (const r of rows) items[r.id] = r;
    render();
  }

  function escapeHtml(s='') { return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }
  function timeAgo(iso) {
    if (!iso) return '';
    const s = Math.floor((Date.now() - new Date(iso).getTime())/1000);
    const units = [[31536000,'y'],[2592000,'mo'],[604800,'w'],[86400,'d'],[3600,'h'],[60,'m']];
    for (const [sec,label] of units) if (s >= sec) return `${Math.floor(s/sec)}${label} ago`;
    return s > 5 ? `${s}s ago` : 'just now';
  }

  function rowEl(it) {
    const row = document.createElement('div');
    row.className = 'item';
    const left = document.createElement('div');

    const input = document.createElement('input');
    input.className = 'input';
    input.value = it.text;
    input.placeholder = 'Edit item…';
    input.oninput = () => scheduleEdit(it.id, input.value);

    const meta = document.createElement('small');
    meta.textContent = `by ${it.author || 'unknown'} · ${timeAgo(it.updatedAt)}`;

    left.appendChild(input);
    left.appendChild(meta);

    const right = document.createElement('div');
    const del = document.createElement('button'); del.className = 'btn danger'; del.textContent = 'Delete';
    del.onclick = () => applyOp({ type: 'delete', id: it.id });
    right.appendChild(del);

    row.appendChild(left); row.appendChild(right);
    return row;
  }

  function render() {
    const list = document.getElementById('list');
    list.innerHTML = '';
    for (const it of toArray(items)) {
      if (it.deleted) continue; // hide tombstoned
      list.appendChild(rowEl(it));
    }
  }

  // -------- Ops & Merge (LWW map with tombstones) --------
  function makeItem(text) {
    return { id: uuid(), text, updatedAt: now(), deleted: false, author: peerId };
  }
  async function applyOp(op, fromPeer=null) {
    if (op.type === 'upsert') {
      const cur = items[op.item.id];
      if (!cur || (cur.updatedAt||'') < (op.item.updatedAt||'')) {
        items[op.item.id] = op.item;
        await put(op.item);
        // render only if not a local text-typing echo to keep caret position
        if (fromPeer !== 'local-typing') render();
      }
    } else if (op.type === 'delete') {
      const cur = items[op.id];
      const tomb = { id: op.id, text: cur ? cur.text : '', updatedAt: now(), deleted: true, author: cur?.author || peerId };
      items[op.id] = tomb; await put(tomb); render();
      op = { type: 'upsert', item: tomb }; // normalize broadcast as upsert of tombstone
    }
    // Broadcast to peers except the sender
    broadcast({ type: 'op', op }, fromPeer);
  }

  // Real-time local typing: debounce and push without re-rendering locally
  const scheduleEdit = debounce(async (id, text) => {
    const it = items[id]; if (!it || it.deleted) return;
    const upd = { ...it, text, updatedAt: now() };
    items[id] = upd; await put(upd);
    broadcast({ type: 'op', op: { type: 'upsert', item: upd } }, 'local-typing');
    // keep UI responsive; no render() here to preserve caret
  }, 80);

  // -------- UI events --------
  document.getElementById('addBtn').onclick = () => {
    const input = document.getElementById('newText');
    const text = (input.value||'').trim(); if (!text) return;
    const it = makeItem(text);
    applyOp({ type: 'upsert', item: it });
    input.value = '';
  };

  // -------- WebRTC (manual copy/paste signaling; iceServers: []) --------
  const peers = new Map(); // id -> { pc, dc }
  const statsEl = document.getElementById('stats');
  function updateStats() {
    const totalPeers = peers.size;
    statsEl.textContent = `${totalPeers} realtime peer${totalPeers===1?'':'s'}`;

    // Update connection status indicator
    const connState = document.getElementById('connState');
    if (totalPeers > 0) {
      connState.innerHTML = '<span class="status-indicator status-connected"></span>connected';
    } else {
      connState.innerHTML = '<span class="status-indicator status-disconnected"></span>disconnected';
    }
  }

  function newPeer() {
    const pc = new RTCPeerConnection({ iceServers: [] }); // no STUN/TURN
    const id = uuid().slice(0,6);
    let dc;

    pc.ondatachannel = (e) => { dc = e.channel; setupDC(id, pc, dc); };

    pc.oniceconnectionstatechange = () => {
      document.getElementById('connState').textContent = pc.iceConnectionState;
      if (['disconnected','failed','closed'].includes(pc.iceConnectionState)) {
        peers.delete(id); updateStats();
      }
    };

    peers.set(id, { pc, dc: null }); updateStats();
    return { id, pc, get dc() { return dc || peers.get(id).dc; }, set dc(v){ const p = peers.get(id); p.dc = v; peers.set(id,p); } };
  }

  function setupDC(id, pc, dc) {
    dc.binaryType = 'arraybuffer';
    dc.onopen = () => { console.log('dc open', id); syncFull(dc); };
    dc.onmessage = (ev) => handleMessage(ev.data, id);
    dc.onclose = () => { peers.delete(id); updateStats(); };
    const p = peers.get(id) || { pc };
    p.dc = dc; peers.set(id, p); updateStats();
  }

  function broadcast(obj, exceptId=null) {
    // include origin for local-tab dedupe
    const msg = { ...obj, origin: peerId };
    const data = JSON.stringify(msg);
    for (const [id, {dc}] of peers) if (dc && dc.readyState === 'open' && id !== exceptId) dc.send(data);
    // Also sync across local tabs in real time
    try { bc.postMessage(msg); } catch {}
  }

  async function handleMessage(data, fromId) {
    let msg; try { msg = typeof data === 'string' ? JSON.parse(data) : data; } catch { return; }
    if (msg.origin && msg.origin === peerId) return; // ignore our own echoes via BroadcastChannel

    if (msg.type === 'full-sync') {
      const remote = msg.items || {};
      for (const id of Object.keys(remote)) {
        const a = items[id]; const b = remote[id];
        if (!a || (a.updatedAt||'') < (b.updatedAt||'')) { items[id] = b; await put(b); }
      }
      render();
    } else if (msg.type === 'op') {
      await applyOp(msg.op, fromId);
    } else if (msg.type === 'presence') {
      presenceLocalTabs.add(msg.tabId||'?'); updateStats();
    }
  }

  function syncFull(dc) {
    const payload = { type: 'full-sync', items };
    try { dc.send(JSON.stringify({ ...payload, origin: peerId })); } catch {}
  }

  // --- Signaling helpers (copy/paste + QR codes) ---
  async function createOffer() {
    const { id, pc } = newPeer();
    const dc = pc.createDataChannel('data');
    setupDC(id, pc, dc);
    const offer = await pc.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: false });
    await pc.setLocalDescription(offer);
    await waitForIceGathering(pc);

    const offerData = b64(JSON.stringify({ sdp: pc.localDescription }));

    // Update UI
    document.getElementById('localOffer').value = offerData;
    document.getElementById('qrSection').style.display = 'block';
    document.getElementById('manualSection').open = false;

    // Generate QR Code
    const qrContainer = document.getElementById('offerQR');
    qrContainer.innerHTML = '<p style="color: #8aa0ff; font-size: 12px;">⏳ Generating QR code...</p>';
    
    // Try QRCode library first, then fallback
    const generateOfferQR = () => {
      if (qrCodeReady) {
        qrContainer.innerHTML = '';
        QRCode.toCanvas(qrContainer, offerData, {
          width: 200,
          height: 200,
          color: { dark: '#f3f6ff', light: '#0f1530' }
        }, function (error) {
          if (error) {
            console.error('QRCode library failed, using fallback:', error);
            generateFallbackQR(qrContainer, offerData);
          }
        });
      } else {
        // Use fallback QR generation
        console.log('QRCode library not ready, using fallback');
        generateFallbackQR(qrContainer, offerData);
      }
    };
    
    // Try immediately, then wait if needed
    setTimeout(generateOfferQR, 100);

    // Auto-copy to clipboard
    try {
      await navigator.clipboard.writeText(offerData);
      showNotification('📋 Offer copied to clipboard!');
    } catch (err) {
      console.log('Clipboard copy failed, user can copy manually');
    }
  }

  async function applyAnswer() {
    const answerText = document.getElementById('remoteAnswer').value.trim();
    if (!answerText) return alert('Paste an Answer');
    const { pc } = Array.from(peers.values())[peers.size - 1] || {};
    if (!pc) return alert('No pending peer. Click Create Offer first.');
    const { sdp } = JSON.parse(ub64(answerText));
    await pc.setRemoteDescription(sdp);
    document.getElementById('remoteAnswer').value = '';
  }

  async function createAnswer() {
    const offerText = document.getElementById('remoteOffer').value.trim();
    if (!offerText) return alert('Paste an Offer or scan a QR code');

    try {
      const { id, pc } = newPeer();
      const { sdp: offer } = JSON.parse(ub64(offerText));
      await pc.setRemoteDescription(offer);
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      await waitForIceGathering(pc);

      const answerData = b64(JSON.stringify({ sdp: pc.localDescription }));

      // Update UI
      document.getElementById('localAnswer').value = answerData;
      document.getElementById('answerSection').style.display = 'block';
      document.getElementById('manualAnswerSection').open = false;

      // Generate QR Code
      const qrContainer = document.getElementById('answerQR');
      qrContainer.innerHTML = '<p style="color: #8aa0ff; font-size: 12px;">⏳ Generating QR code...</p>';
      
      // Try QRCode library first, then fallback
      const generateAnswerQR = () => {
        if (qrCodeReady) {
          qrContainer.innerHTML = '';
          QRCode.toCanvas(qrContainer, answerData, {
            width: 200,
            height: 200,
            color: { dark: '#f3f6ff', light: '#0f1530' }
          }, function (error) {
            if (error) {
              console.error('QRCode library failed, using fallback:', error);
              generateFallbackQR(qrContainer, answerData);
            }
          });
        } else {
          // Use fallback QR generation
          console.log('QRCode library not ready, using fallback');
          generateFallbackQR(qrContainer, answerData);
        }
      };
      
      // Try immediately, then wait if needed
      setTimeout(generateAnswerQR, 100);

      // Auto-copy to clipboard
      try {
        await navigator.clipboard.writeText(answerData);
        showNotification('📋 Answer copied to clipboard!');
      } catch (err) {
        console.log('Clipboard copy failed, user can copy manually');
      }

      document.getElementById('remoteOffer').value = '';
    } catch (error) {
      alert('Invalid offer data. Please check and try again.');
    }
  }

  function disconnectAll() {
    for (const [id, {pc}] of peers) { try { pc.close(); } catch {} }
    peers.clear(); updateStats();
    document.getElementById('connState').textContent = 'disconnected';
    document.getElementById('connState').innerHTML = '<span class="status-indicator status-disconnected"></span>disconnected';

    // Hide QR sections
    document.getElementById('qrSection').style.display = 'none';
    document.getElementById('answerSection').style.display = 'none';
  }

  function waitForIceGathering(pc) {
    return new Promise((resolve) => {
      if (pc.iceGatheringState === 'complete') return resolve();
      const check = () => pc.iceGatheringState === 'complete' && resolve();
      pc.addEventListener('icegatheringstatechange', check);
      setTimeout(resolve, 1500);
    });
  }

  function b64(s) { return btoa(unescape(encodeURIComponent(s))); }
  function ub64(s) { return decodeURIComponent(escape(atob(s))); }

  // --- Fallback QR Code Generation ---
  function generateFallbackQR(container, text) {
    // Create a simple QR code using an online service as fallback
    const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(text)}&bgcolor=0f1530&color=f3f6ff`;
    
    const img = document.createElement('img');
    img.src = qrUrl;
    img.style.cssText = 'width: 200px; height: 200px; border-radius: 8px;';
    img.onerror = () => {
      container.innerHTML = '<p style="color: #ff6b6b; font-size: 12px;">QR generation failed. Use manual copy below.</p>';
    };
    
    container.innerHTML = '';
    container.appendChild(img);
  }

  // --- UI Helpers ---
  function showNotification(message) {
    // Create notification element
    const notification = document.createElement('div');
    notification.textContent = message;
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #5ee6a8;
      color: #0b1020;
      padding: 12px 16px;
      border-radius: 8px;
      font-weight: 600;
      z-index: 1000;
      animation: slideIn 0.3s ease-out;
    `;
    document.body.appendChild(notification);

    // Remove after 3 seconds
    setTimeout(() => {
      notification.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(() => notification.remove(), 300);
    }, 3000);
  }

  // Add notification animations to CSS
  const style = document.createElement('style');
  style.textContent = `
    @keyframes slideIn {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    @keyframes slideOut {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }
  `;
  document.head.appendChild(style);

  // --- QR Scanner ---
  let scannerStream = null;
  let scanInterval = null;
  let isMirrored = false; // Track mirror state
  let isBackCamera = false; // Track camera type

  // Auto-detect camera type and set initial mirror state
  function detectCameraType(stream) {
    const videoTrack = stream.getVideoTracks()[0];
    if (videoTrack) {
      const settings = videoTrack.getSettings();
      const capabilities = videoTrack.getCapabilities();
      
      console.log('Camera settings:', settings);
      console.log('Camera capabilities:', capabilities);
      
      // Try to detect if it's a back camera
      if (settings.facingMode) {
        isBackCamera = settings.facingMode === 'environment';
        console.log('Camera facing mode:', settings.facingMode);
      } else if (videoTrack.label) {
        // Check label for back camera indicators
        const label = videoTrack.label.toLowerCase();
        isBackCamera = label.includes('back') || label.includes('rear') || label.includes('environment');
        console.log('Camera label:', videoTrack.label, 'isBackCamera:', isBackCamera);
      }
      
      // Set initial mirror state: mirror for front cameras, no mirror for back cameras
      isMirrored = !isBackCamera;
      console.log('Initial mirror state:', isMirrored ? 'ON' : 'OFF');
      
      return isBackCamera;
    }
    return false;
  }

  function updateMirrorState(videoElement) {
    // Update video element mirroring
    if (videoElement) {
      videoElement.style.transform = isMirrored ? 'scaleX(-1)' : 'scaleX(1)';
    }
    
    // Update mirror button text
    const mirrorBtn = document.getElementById('mirrorBtn');
    if (mirrorBtn) {
      mirrorBtn.textContent = isMirrored ? '🪞 Mirror: ON' : '🪞 Mirror: OFF';
      mirrorBtn.title = isMirrored ? 'Click to turn off mirroring' : 'Click to turn on mirroring';
    }
  }

  window.toggleMirror = function() {
    isMirrored = !isMirrored;
    console.log('Mirror toggled:', isMirrored ? 'ON' : 'OFF');
    
    const video = document.getElementById('qrVideo');
    updateMirrorState(video);
  };

  // Make functions globally accessible
  window.saveCurrentFrame = function() {
    console.log('=== SAVING CURRENT FRAME ===');
    const video = document.getElementById('qrVideo');
    const canvas = document.getElementById('qrCanvas');
    const ctx = canvas.getContext('2d');
    
    if (!video || !canvas) {
      console.log('Video or canvas not found');
      return;
    }
    
    // Draw current frame with mirror state
    ctx.save();
    if (isMirrored) {
      ctx.scale(-1, 1);
      ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
    } else {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    }
    ctx.restore();
    
    // Convert to blob and download
    canvas.toBlob(function(blob) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'qr-scanner-frame.png';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      console.log('Frame saved as qr-scanner-frame.png');
    });
  };

  window.manualDetectionTest = function() {
    console.log('=== MANUAL DETECTION TEST ===');
    const video = document.getElementById('qrVideo');
    const canvas = document.getElementById('qrCanvas');
    const ctx = canvas.getContext('2d');
    
    if (!video || !canvas) {
      console.log('Video or canvas not found');
      return;
    }
    
    console.log('Video ready state:', video.readyState);
    console.log('Video dimensions:', video.videoWidth, 'x', video.videoHeight);
    console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
    
    // Draw current frame
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    
    console.log('Image data length:', imageData.data.length);
    console.log('First 20 pixels (RGBA):', Array.from(imageData.data.slice(0, 80)));
    
    // Try detection with different methods
    console.log('Testing jsQR detection...');
    
    if (typeof jsQR !== 'undefined') {
      // Test 1: Normal
      const result1 = jsQR(imageData.data, imageData.width, imageData.height);
      console.log('Normal detection result:', result1);
      
      // Test 2: With inversion
      const result2 = jsQR(imageData.data, imageData.width, imageData.height, {
        inversionAttempts: "attemptBoth"
      });
      console.log('Inversion detection result:', result2);
      
      // Test 3: Manual threshold
      const grayscaleData = new Uint8ClampedArray(imageData.data.length);
      for (let i = 0; i < imageData.data.length; i += 4) {
        const gray = Math.round(0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2]);
        const binary = gray > 128 ? 255 : 0;
        grayscaleData[i] = binary;
        grayscaleData[i + 1] = binary;
        grayscaleData[i + 2] = binary;
        grayscaleData[i + 3] = imageData.data[i + 3];
      }
      
      const result3 = jsQR(grayscaleData, imageData.width, imageData.height);
      console.log('Binary threshold detection result:', result3);
    } else {
      console.log('jsQR library not available');
    }
    
    console.log('=== END MANUAL TEST ===');
  };

  window.stopQRScanner = function() {
    console.log('Stopping QR scanner');

    // Stop scanning interval
    if (scanInterval) {
      clearInterval(scanInterval);
      scanInterval = null;
    }

    // Stop camera stream
    if (scannerStream) {
      scannerStream.getTracks().forEach(track => track.stop());
      scannerStream = null;
    }

    // Remove modal
    const modal = document.getElementById('qrScannerModal');
    if (modal) {
      modal.remove();
    }
  };

  window.processManualQR = function(targetInputId) {
    const input = document.getElementById('manualQRInput');
    const targetInput = document.getElementById(targetInputId);
    if (input && input.value && targetInput) {
      targetInput.value = input.value;
      window.stopQRScanner();
      showNotification('📱 QR code processed successfully!');
    }
  };

  async function startQRScanner(targetInputId) {
    console.log('Starting QR scanner for:', targetInputId);

    try {
      // Try back camera first (better for QR scanning)
      let stream;
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'environment', // Back camera
            width: { ideal: 640 },
            height: { ideal: 480 }
          }
        });
        console.log('✅ Back camera acquired');
      } catch (e) {
        console.log('Back camera not available, trying front camera:', e.message);
        // Fallback to front camera
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'user', // Front camera
            width: { ideal: 640 },
            height: { ideal: 480 }
          }
        });
        console.log('✅ Front camera acquired');
      }

      scannerStream = stream;
      
      // Detect camera type and set initial mirror state
      detectCameraType(stream);
      
      const video = document.createElement('video');
      video.srcObject = stream;
      video.setAttribute('playsinline', ''); // Required for iOS
      video.setAttribute('autoplay', ''); // Ensure autoplay
      video.setAttribute('muted', ''); // Required for autoplay in some browsers
      video.style.width = '100%';
      video.style.maxWidth = '300px';
      video.style.borderRadius = '8px';
      video.style.background = '#000';
      
      // Set initial mirroring based on camera type
      updateMirrorState(video);

      // Wait for video to be ready
      await new Promise((resolve) => {
        video.onloadedmetadata = () => {
          console.log('Video metadata loaded, dimensions:', video.videoWidth, 'x', video.videoHeight);
          resolve();
        };
        video.oncanplay = () => {
          console.log('Video can play');
          // Update status when video is ready
          const statusEl = document.getElementById('scannerStatus');
          if (statusEl) {
            statusEl.textContent = jsQRReady ? '✅ Camera ready - Scanner active' : '📷 Camera ready - Loading scanner...';
            statusEl.style.color = '#5ee6a8';
          }
        };
        video.play().then(() => {
          console.log('Video started playing');
        }).catch(err => {
          console.error('Video play failed:', err);
          const statusEl = document.getElementById('scannerStatus');
          if (statusEl) {
            statusEl.textContent = '❌ Video playback failed';
            statusEl.style.color = '#ff6b6b';
          }
        });
      });

      // Create scanner modal
      const modal = document.createElement('div');
      modal.id = 'qrScannerModal';
      modal.style.cssText = `
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
      `;

      const scannerContainer = document.createElement('div');
      scannerContainer.style.cssText = `
        background: #0f1530;
        padding: 20px;
        border-radius: 16px;
        text-align: center;
        max-width: 90vw;
        position: relative;
      `;

      scannerContainer.innerHTML = `
        <h3 style="color: #f3f6ff; margin: 0 0 16px;">📷 Scan QR Code</h3>
        <div id="scannerStatus" style="color: #8aa0ff; font-size: 12px; margin-bottom: 16px;">
          ${jsQRReady ? '✅ Scanner ready' : '⏳ Loading scanner...'}
        </div>
      `;

      // Add video container
      const videoContainer = document.createElement('div');
      videoContainer.style.cssText = 'position: relative; display: inline-block; margin-bottom: 16px;';

      // Add scanning frame overlay
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 200px;
        height: 200px;
        border: 2px solid #5ee6a8;
        border-radius: 8px;
        pointer-events: none;
        box-shadow: 0 0 0 2px rgba(94, 230, 168, 0.3);
      `;

      videoContainer.appendChild(video);
      videoContainer.appendChild(overlay);
      scannerContainer.appendChild(videoContainer);

      // Add instructions
      const instructions = document.createElement('p');
      instructions.textContent = 'Position QR code within the frame';
      instructions.style.cssText = 'color: #8aa0ff; font-size: 14px; margin: 16px 0;';
      scannerContainer.appendChild(instructions);

      // Add test section for debugging
      const testSection = document.createElement('div');
      testSection.style.cssText = 'margin: 8px 0; padding: 8px; background: #1a2249; border-radius: 8px;';
      testSection.innerHTML = `
        <details style="color: #8aa0ff;">
          <summary style="cursor: pointer; font-size: 12px;">🔧 Test Scanner</summary>
          <div style="margin-top: 8px;">
            <p style="font-size: 11px; margin: 4px 0;">Test with this simple text: <strong style="color: #f3f6ff;">Hello World</strong></p>
            <img src="https://api.qrserver.com/v1/create-qr-code/?size=80x80&data=Hello%20World" 
                 style="width: 60px; height: 60px; margin: 4px; border: 1px solid #5ee6a8;">
            <p style="font-size: 11px; color: #c5ceff99;">Hold this QR code up to your camera to test scanning</p>
          </div>
        </details>
      `;
      scannerContainer.appendChild(testSection);

      // Add controls
      const controls = document.createElement('div');
      controls.style.cssText = 'margin-top: 16px;';
      controls.innerHTML = `
        <div style="margin-bottom: 10px;">
          <button class="btn" onclick="window.toggleMirror()" id="mirrorBtn">🪞 Toggle Mirror</button>
          <button class="btn primary" onclick="window.manualDetectionTest()" style="margin-left: 10px;">🔍 Test Detection</button>
          <button class="btn" onclick="window.saveCurrentFrame()" style="margin-left: 10px;">💾 Save Frame</button>
        </div>
        <div>
          <button class="btn danger" onclick="window.stopQRScanner()">❌ Cancel</button>
        </div>
      `;
      scannerContainer.appendChild(controls);

      modal.appendChild(scannerContainer);
      document.body.appendChild(modal);

      // Add manual input option
      addManualInputOption(scannerContainer, targetInputId);

      // Start scanning
      startScanning(video, targetInputId);

    } catch (error) {
      console.error('Camera access error:', error);
      alert('Camera access denied or not available. Please paste the code manually.');
    }
  }

  function addManualInputOption(container, targetInputId) {
    const manualDiv = document.createElement('div');
    manualDiv.id = 'manualInputSection';
    manualDiv.style.cssText = 'margin-top: 16px; padding-top: 16px; border-top: 1px solid #2c3978;';
    manualDiv.innerHTML = `
      <p style="color: #c5ceff99; font-size: 14px; margin-bottom: 8px;">Or paste the code manually:</p>
      <input type="text" id="manualQRInput" class="input" placeholder="Paste QR code content here" style="margin-bottom: 10px; width: 100%;">
      <button class="btn accent" onclick="window.processManualQR('${targetInputId}')">✅ Use This Code</button>
    `;
    container.appendChild(manualDiv);
  }

  function startScanning(videoElement, targetInputId) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true }); // Fix performance warning
    
    // Add scan counter for debugging
    let scanCount = 0;
    
    scanInterval = setInterval(() => {
      if (!scannerStream) {
        clearInterval(scanInterval);
        return;
      }

      try {
        if (videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {
          console.log('Video not ready yet');
          return;
        }

        // Set canvas dimensions once
        if (canvas.width !== videoElement.videoWidth || canvas.height !== videoElement.videoHeight) {
          canvas.width = videoElement.videoWidth;
          canvas.height = videoElement.videoHeight;
          console.log('Canvas resized to:', canvas.width, 'x', canvas.height);
        }
        
        // Draw video with respect to mirror state
        ctx.save();
        if (isMirrored) {
          ctx.scale(-1, 1);
          ctx.drawImage(videoElement, -canvas.width, 0, canvas.width, canvas.height);
        } else {
          ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
        }
        ctx.restore();

        // Get image data for QR detection
        let imageData;
        try {
          imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        } catch (e) {
          console.log('Failed to get ImageData:', e);
          return;
        }
        
        // Validate ImageData before processing
        if (!imageData || !imageData.data || imageData.data.length === 0) {
          console.log('Invalid ImageData received');
          return;
        }
        
        const expectedLength = canvas.width * canvas.height * 4;
        if (imageData.data.length !== expectedLength) {
          console.log('ImageData length mismatch. Expected:', expectedLength, 'Got:', imageData.data.length);
          return;
        }
        
        // Update scan count every 10 scans
        scanCount++;
        if (scanCount % 10 === 0) {
          const videoElement = document.getElementById('qrVideo');
          console.log(`Scanning attempt ${scanCount}, image size: ${canvas.width}x${canvas.height}`);
          if (videoElement) {
            console.log('Video dimensions:', videoElement.videoWidth, 'x', videoElement.videoHeight);
          }
          console.log('ImageData bytes:', imageData.data.length);
          
          // Sample some pixel data to verify we're getting real image data
          const samplePixels = [];
          for (let i = 0; i < 5; i++) {
            const idx = Math.floor(Math.random() * imageData.data.length / 4) * 4;
            samplePixels.push([
              imageData.data[idx], 
              imageData.data[idx + 1], 
              imageData.data[idx + 2]
            ]);
          }
          console.log('Sample pixels (RGB):', samplePixels);
          
          const statusEl = document.getElementById('scannerStatus');
          if (statusEl) {
            statusEl.textContent = `✅ Scanning... (${scanCount} attempts)`;
          }
        }
        
        // Detect QR code with multiple attempts
        let qrText = detectQRFromImageData(imageData);
        
        // Try with inverted colors if first attempt fails
        if (!qrText && scanCount % 5 === 0) {
          // Create inverted image data
          const invertedImageData = ctx.createImageData(imageData.width, imageData.height);
          for (let i = 0; i < imageData.data.length; i += 4) {
            // Invert RGB, keep alpha
            invertedImageData.data[i] = 255 - imageData.data[i];     // R
            invertedImageData.data[i + 1] = 255 - imageData.data[i + 1]; // G
            invertedImageData.data[i + 2] = 255 - imageData.data[i + 2]; // B
            invertedImageData.data[i + 3] = imageData.data[i + 3];       // A
          }
          qrText = detectQRFromImageDataInverted(invertedImageData);
        }
        
        // Try cropping to center area every 15 scans
        if (!qrText && scanCount % 15 === 0) {
          const centerSize = Math.min(canvas.width, canvas.height) * 0.6;
          const startX = Math.floor((canvas.width - centerSize) / 2);
          const startY = Math.floor((canvas.height - centerSize) / 2);
          
          // Ensure crop dimensions are valid
          if (centerSize > 0 && startX >= 0 && startY >= 0 && 
              startX + centerSize <= canvas.width && startY + centerSize <= canvas.height) {
            const croppedData = ctx.getImageData(startX, startY, Math.floor(centerSize), Math.floor(centerSize));
            qrText = detectQRFromImageData(croppedData);
          }
          
          if (scanCount % 30 === 0) {
            console.log('Trying center crop scan, area:', Math.round(centerSize), 'x', Math.round(centerSize));
          }
        }
        
        if (qrText) {
          console.log('QR Code detected:', qrText);
          processScannedQR(qrText, targetInputId);
        }
      } catch (error) {
        console.error('Scanning error:', error);
      }
    }, 300); // Scan every 300ms to reduce errors
  }

  function detectQRFromImageData(imageData) {
    if (typeof jsQR === 'undefined') {
      console.log('jsQR library not loaded');
      return null;
    }

    // Validate ImageData object thoroughly
    if (!imageData) {
      console.log('ImageData is null or undefined');
      return null;
    }
    
    if (!imageData.data || !(imageData.data instanceof Uint8ClampedArray)) {
      console.log('ImageData.data is invalid:', typeof imageData.data);
      return null;
    }
    
    if (typeof imageData.width !== 'number' || typeof imageData.height !== 'number') {
      console.log('ImageData dimensions are invalid:', imageData.width, imageData.height);
      return null;
    }
    
    if (imageData.width <= 0 || imageData.height <= 0) {
      console.log('ImageData dimensions are zero or negative:', imageData.width, imageData.height);
      return null;
    }

    // Check if data length matches dimensions
    const expectedLength = imageData.width * imageData.height * 4;
    if (imageData.data.length !== expectedLength) {
      console.log('ImageData size mismatch. Expected:', expectedLength, 'Got:', imageData.data.length);
      return null;
    }

    // Create a copy of the data to avoid any reference issues
    const dataArray = new Uint8ClampedArray(imageData.data);

    try {
      // Try different detection methods with the copied data
      console.log('Attempting QR detection on', imageData.width, 'x', imageData.height, 'image');
      
      // Method 1: Normal detection
      let code = jsQR(dataArray, imageData.width, imageData.height, {
        inversionAttempts: "dontInvert",
      });
      
      if (code) {
        console.log('✅ QR Code detected (normal):', code.data);
        return code.data;
      }
      
      // Method 2: With inversion
      code = jsQR(dataArray, imageData.width, imageData.height, {
        inversionAttempts: "onlyInvert",
      });
      
      if (code) {
        console.log('✅ QR Code detected (inverted):', code.data);
        return code.data;
      }
      
      // Method 3: Auto detection
      code = jsQR(dataArray, imageData.width, imageData.height, {
        inversionAttempts: "attemptBoth",
      });
      
      if (code) {
        console.log('✅ QR Code detected (auto):', code.data);
        return code.data;
      }
      
    } catch (error) {
      console.error('❌ QR detection error:', error.message);
      console.log('ImageData state:', {
        width: imageData.width,
        height: imageData.height,
        dataLength: imageData.data.length,
        dataType: typeof imageData.data,
        firstPixels: Array.from(imageData.data.slice(0, 16))
      });
    }
    return null;
  }

  function detectQRFromImageDataInverted(imageData) {
    if (typeof jsQR === 'undefined') {
      return null;
    }

    try {
      const code = jsQR(imageData.data, imageData.width, imageData.height, {
        inversionAttempts: "attemptBoth",
      });
      
      if (code) {
        console.log('QR Code detected (inverted):', code.data);
        return code.data;
      }
    } catch (error) {
      console.error('QR detection error (inverted):', error);
    }
    return null;
  }

  function processScannedQR(qrText, targetInputId) {
    const targetInput = document.getElementById(targetInputId);
    if (targetInput && qrText) {
      targetInput.value = qrText;
      window.stopQRScanner();
      showNotification('📱 QR code scanned successfully!');
    }
  }
  const bc = new BroadcastChannel('p2p-items-v1');
  bc.onmessage = (e) => handleMessage(e.data, 'bc');
  const presenceLocalTabs = new Set();
  function pulsePresence() {
    try { bc.postMessage({ type:'presence', tabId: peerId + ':' + tabStamp, origin: peerId }); } catch {}
  }
  const tabStamp = Math.random().toString(36).slice(2,6);
  setInterval(pulsePresence, 2000);

  // -------- Export / Import --------
  document.getElementById('exportBtn').onclick = async () => {
    const blob = new Blob([JSON.stringify({ items }, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `p2p-items-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
    a.click();
  };
  document.getElementById('importBtn').onclick = () => document.getElementById('filePick').click();
  document.getElementById('filePick').onchange = async (e) => {
    const f = e.target.files[0]; if (!f) return;
    const text = await f.text();
    let obj; try { obj = JSON.parse(text); } catch { return alert('Invalid JSON'); }
    if (obj && obj.items) {
      for (const it of Object.values(obj.items)) { await put(it); items[it.id] = it; }
      render();
      broadcast({ type: 'full-sync', items });
    }
  };

  // -------- Buttons wiring --------
  console.log('Setting up button event handlers...');

  document.getElementById('createOfferBtn').onclick = () => {
    console.log('Create Offer button clicked');
    createOffer();
  };
  document.getElementById('applyAnswerBtn').onclick = () => {
    console.log('Apply Answer button clicked');
    applyAnswer();
  };
  document.getElementById('createAnswerBtn').onclick = () => {
    console.log('Create Answer button clicked');
    createAnswer();
  };
  document.getElementById('disconnectBtn').onclick = () => {
    console.log('Disconnect button clicked');
    disconnectAll();
  };

  // Copy button handlers
  document.getElementById('copyOfferBtn').onclick = async () => {
    console.log('Copy Offer button clicked');
    const text = document.getElementById('localOffer').value;
    try {
      await navigator.clipboard.writeText(text);
      showNotification('📋 Offer copied to clipboard!');
    } catch (err) {
      console.error('Clipboard copy failed:', err);
      alert('Failed to copy to clipboard. Please copy manually.');
    }
  };

  document.getElementById('copyOfferTextBtn').onclick = async () => {
    console.log('Copy Offer Text button clicked');
    const text = document.getElementById('localOffer').value;
    try {
      await navigator.clipboard.writeText(text);
      showNotification('📋 Offer text copied!');
    } catch (err) {
      console.error('Clipboard copy failed:', err);
      alert('Failed to copy to clipboard. Please copy manually.');
    }
  };

  document.getElementById('copyAnswerBtn').onclick = async () => {
    console.log('Copy Answer button clicked');
    const text = document.getElementById('localAnswer').value;
    try {
      await navigator.clipboard.writeText(text);
      showNotification('📋 Answer copied to clipboard!');
    } catch (err) {
      console.error('Clipboard copy failed:', err);
      alert('Failed to copy to clipboard. Please copy manually.');
    }
  };

  document.getElementById('copyAnswerTextBtn').onclick = async () => {
    console.log('Copy Answer Text button clicked');
    const text = document.getElementById('localAnswer').value;
    try {
      await navigator.clipboard.writeText(text);
      showNotification('📋 Answer text copied!');
    } catch (err) {
      console.error('Clipboard copy failed:', err);
      alert('Failed to copy to clipboard. Please copy manually.');
    }
  };

  document.getElementById('scanOfferBtn').onclick = () => {
    console.log('Scan Offer button clicked');
    startQRScanner('remoteOffer');
  };

  // -------- Init --------
  await loadFromDB();
})();
</script>

<!-- Simple Test QR Code for Scanner Testing -->
<div style="position: fixed; top: 10px; right: 10px; z-index: 1000; background: white; padding: 10px; border: 2px solid #007bff; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
  <div style="text-align: center; margin-bottom: 10px;">
    <strong style="color: #007bff; font-size: 12px;">📱 SCANNER TEST</strong>
  </div>
  <div id="simpleTestQR"></div>
  <div style="text-align: center; margin-top: 5px; font-size: 10px; color: #6c757d;">
    Content: "HELLO"
  </div>
</div>

<script>
  // Generate a very simple test QR code
  setTimeout(() => {
    try {
      if (typeof QRCode !== 'undefined') {
        new QRCode(document.getElementById("simpleTestQR"), {
          text: "HELLO",
          width: 80,
          height: 80,
          colorDark: "#000000",
          colorLight: "#ffffff",
          correctLevel: QRCode.CorrectLevel.L  // Lowest error correction for simpler pattern
        });
      }
    } catch (e) {
      console.log('Failed to generate simple test QR:', e);
    }
  }, 1000);
</script>

</body>
</html>
